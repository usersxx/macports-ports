--- common/autoconf/lib-ffi.m4
+++ common/autoconf/lib-ffi.m4
@@ -85,6 +85,20 @@ AC_DEFUN_ONCE([LIB_SETUP_LIBFFI],
           [LIBFFI_FOUND=no]
       )
     fi
+    # on macos we need a special case for system's libffi as
+    # headers are located only in sdk in $SYSROOT and in ffi subfolder
+    if test "x$LIBFFI_FOUND" = xno; then
+      if test "x$SYSROOT" != "x"; then
+        AC_CHECK_HEADER([$SYSROOT/usr/include/ffi/ffi.h],
+            [
+              LIBFFI_FOUND=yes
+              LIBFFI_CFLAGS="-I${SYSROOT}/usr/include/ffi"
+              LIBFFI_LIBS=-lffi
+            ],
+            [LIBFFI_FOUND=no]
+        )
+      fi
+    fi
     if test "x$LIBFFI_FOUND" = xno; then
       HELP_MSG_MISSING_DEPENDENCY([ffi])
       AC_MSG_ERROR([Could not find libffi! $HELP_MSG])

--- hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp
+++ hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp
@@ -366,42 +366,42 @@
     return 1;
   }
 
-  void _Copy_conjoint_jshorts_atomic(jshort* from, jshort* to, size_t count) {
+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {
     if (from > to) {
-      jshort *end = from + count;
+      const jshort *end = from + count;
       while (from < end)
         *(to++) = *(from++);
     }
     else if (from < to) {
-      jshort *end = from;
+      const jshort *end = from;
       from += count - 1;
       to   += count - 1;
       while (from >= end)
         *(to--) = *(from--);
     }
   }
-  void _Copy_conjoint_jints_atomic(jint* from, jint* to, size_t count) {
+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {
     if (from > to) {
-      jint *end = from + count;
+      const jint *end = from + count;
       while (from < end)
         *(to++) = *(from++);
     }
     else if (from < to) {
-      jint *end = from;
+      const jint *end = from;
       from += count - 1;
       to   += count - 1;
       while (from >= end)
         *(to--) = *(from--);
     }
   }
-  void _Copy_conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count) {
+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {
     if (from > to) {
-      jlong *end = from + count;
+      const jlong *end = from + count;
       while (from < end)
         os::atomic_copy64(from++, to++);
     }
     else if (from < to) {
-      jlong *end = from;
+      const jlong *end = from;
       from += count - 1;
       to   += count - 1;
       while (from >= end)
@@ -409,22 +409,22 @@
     }
   }
 
-  void _Copy_arrayof_conjoint_bytes(HeapWord* from,
+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,
                                     HeapWord* to,
                                     size_t    count) {
     memmove(to, from, count);
   }
-  void _Copy_arrayof_conjoint_jshorts(HeapWord* from,
+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,
                                       HeapWord* to,
                                       size_t    count) {
     memmove(to, from, count * 2);
   }
-  void _Copy_arrayof_conjoint_jints(HeapWord* from,
+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,
                                     HeapWord* to,
                                     size_t    count) {
     memmove(to, from, count * 4);
   }
-  void _Copy_arrayof_conjoint_jlongs(HeapWord* from,
+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,
                                      HeapWord* to,
                                      size_t    count) {
     memmove(to, from, count * 8);

--- src/hotspot/share/runtime/java.cpp
+++ src/hotspot/share/runtime/java.cpp
@@ -65,6 +65,7 @@
 #include "runtime/thread.inline.hpp"
 #include "runtime/timer.hpp"
 #include "runtime/vm_operations.hpp"
+#include "runtime/vmThread.hpp"
 #include "services/memTracker.hpp"
 #include "trace/traceMacros.hpp"
 #include "trace/tracing.hpp"

--- src/hotspot/share/runtime/sharedRuntime.cpp
+++ src/hotspot/share/runtime/sharedRuntime.cpp
@@ -93,6 +93,7 @@
 
 //----------------------------generate_stubs-----------------------------------
 void SharedRuntime::generate_stubs() {
+#ifndef ZERO
   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          "wrong_method_stub");
   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), "wrong_method_abstract_stub");
   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  "ic_miss_stub");
@@ -100,6 +101,7 @@
   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       "resolve_virtual_call");
   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        "resolve_static_call");
   _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();
+#endif
 
 #if COMPILER2_OR_JVMCI
   // Vectors are generated only by C2 and JVMCI.
@@ -2584,7 +2586,12 @@
   // throw AbstractMethodError just in case.
   // Pass wrong_method_abstract for the c2i transitions to return
   // AbstractMethodError for invalid invocations.
-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
+  address wrong_method_abstract =
+#ifdef ZERO
+                                  NULL;
+#else
+                                  SharedRuntime::get_handle_wrong_method_abstract_stub();
+#endif
   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),
                                                               StubRoutines::throw_AbstractMethodError_entry(),
                                                               wrong_method_abstract, wrong_method_abstract);

--- hotspot/src/share/vm/runtime/stubRoutines.cpp
+++ hotspot/src/share/vm/runtime/stubRoutines.cpp
@@ -217,18 +217,21 @@
   // Use middle of array to check that memory before it is not modified.
   address buffer  = align_up((address)&lbuffer[4], BytesPerLong);
   address buffer2 = align_up((address)&lbuffer2[4], BytesPerLong);
+
+  arraycopy_fn copyfunc = CAST_TO_FN_PTR(arraycopy_fn, func);
+
   // do an aligned copy
-  ((arraycopy_fn)func)(buffer, buffer2, 0);
+  copyfunc(buffer, buffer2, 0);
   for (i = 0; i < sizeof(lbuffer); i++) {
     assert(fbuffer[i] == v && fbuffer2[i] == v2, "shouldn't have copied anything");
   }
   // adjust destination alignment
-  ((arraycopy_fn)func)(buffer, buffer2 + alignment, 0);
+  copyfunc(buffer, buffer2 + alignment, 0);
   for (i = 0; i < sizeof(lbuffer); i++) {
     assert(fbuffer[i] == v && fbuffer2[i] == v2, "shouldn't have copied anything");
   }
   // adjust source alignment
-  ((arraycopy_fn)func)(buffer + alignment, buffer2, 0);
+  copyfunc(buffer + alignment, buffer2, 0);
   for (i = 0; i < sizeof(lbuffer); i++) {
     assert(fbuffer[i] == v && fbuffer2[i] == v2, "shouldn't have copied anything");
   }

--- src/hotspot/share/utilities/globalDefinitions.hpp
+++ src/hotspot/share/utilities/globalDefinitions.hpp
@@ -365,8 +365,14 @@
 // so far from the middle of the road that it is likely to be problematic in
 // many C++ compilers.
 //
+#if __has_feature(ptrauth_calls)
+#include <ptrauth.h>
+#define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast<func_type>(value ? ptrauth_sign_unauthenticated(ptrauth_strip((void *)value, ptrauth_key_function_pointer), ptrauth_key_function_pointer, 0) : NULL))
+#define CAST_FROM_FN_PTR(new_type, func_ptr) ((new_type)((address_word)(ptrauth_strip((void *)func_ptr, ptrauth_key_function_pointer))))
+#else
 #define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast<func_type>(value))
 #define CAST_FROM_FN_PTR(new_type, func_ptr) ((new_type)((address_word)(func_ptr)))
+#endif
 
 // Unsigned byte types for os and stream.hpp
 
