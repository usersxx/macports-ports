--- make/Bundles.gmk
+++ make/Bundles.gmk
@@ -278,7 +278,16 @@
       $(SYMBOLS_EXCLUDE_PATTERN), \
       $(ALL_JRE_FILES))
 
-  ifeq ($(MACOSX_CODESIGN_MODE), hardened)
+  # On Macosx release builds, when there is a code signing certificate available,
+  # the final bundle layout can be signed.
+  SIGN_BUNDLE := false
+  ifeq ($(call isTargetOs, macosx)+$(DEBUG_LEVEL), true+release)
+    ifneq ($(CODESIGN), )
+      SIGN_BUNDLE := true
+    endif
+  endif
+
+  ifeq ($(SIGN_BUNDLE), true)
     # Macosx release build and code signing available.
 
     ################################################################################

--- make/autoconf/basic_tools.m4
+++ make/autoconf/basic_tools.m4
@@ -160,23 +160,25 @@
 AC_DEFUN([BASIC_CHECK_MAKE_OUTPUT_SYNC],
 [
   # Check if make supports the output sync option and if so, setup using it.
-  UTIL_ARG_WITH(NAME: output-sync, TYPE: literal,
-      VALID_VALUES: [none recurse line target], DEFAULT: recurse,
-      OPTIONAL: true, ENABLED_DEFAULT: true,
-      ENABLED_RESULT: OUTPUT_SYNC_SUPPORTED,
-      CHECKING_MSG: [for make --output-sync value],
-      DESC: [set make --output-sync type if supported by make],
-      CHECK_AVAILABLE:
-      [
         AC_MSG_CHECKING([if make --output-sync is supported])
-        if ! $MAKE --version -O > /dev/null 2>&1; then
-          AC_MSG_RESULT([no])
-          AVAILABLE=false
-        else
+  if $MAKE --version -O > /dev/null 2>&1; then
+    OUTPUT_SYNC_SUPPORTED=true
           AC_MSG_RESULT([yes])
+    AC_MSG_CHECKING([for output-sync value])
+    AC_ARG_WITH([output-sync], [AS_HELP_STRING([--with-output-sync],
+      [set make output sync type if supported by make. @<:@recurse@:>@])],
+      [OUTPUT_SYNC=$with_output_sync])
+    if test "x$OUTPUT_SYNC" = "x"; then
+      OUTPUT_SYNC=none
+    fi
+    AC_MSG_RESULT([$OUTPUT_SYNC])
+    if ! $MAKE --version -O$OUTPUT_SYNC > /dev/null 2>&1; then
+      AC_MSG_ERROR([Make did not the support the value $OUTPUT_SYNC as output sync type.])
+    fi
+  else
+    OUTPUT_SYNC_SUPPORTED=false
+    AC_MSG_RESULT([no])
         fi
-      ]
-  )
   AC_SUBST(OUTPUT_SYNC_SUPPORTED)
   AC_SUBST(OUTPUT_SYNC)
 ])
@@ -376,6 +378,43 @@
     UTIL_REQUIRE_PROGS(MIG, mig)
     UTIL_REQUIRE_PROGS(XATTR, xattr)
     UTIL_LOOKUP_PROGS(CODESIGN, codesign)
+
+    if test "x$CODESIGN" != "x"; then
+      # Check for user provided code signing identity.
+      # If no identity was provided, fall back to "openjdk_codesign".
+      AC_ARG_WITH([macosx-codesign-identity], [AS_HELP_STRING([--with-macosx-codesign-identity],
+        [specify the code signing identity])],
+        [MACOSX_CODESIGN_IDENTITY=$with_macosx_codesign_identity],
+        [MACOSX_CODESIGN_IDENTITY=openjdk_codesign]
+      )
+
+      AC_SUBST(MACOSX_CODESIGN_IDENTITY)
+
+      # Verify that the codesign certificate is present
+      AC_MSG_CHECKING([if codesign certificate is present])
+      $RM codesign-testfile
+      $TOUCH codesign-testfile
+      $CODESIGN -s "$MACOSX_CODESIGN_IDENTITY" codesign-testfile 2>&AS_MESSAGE_LOG_FD \
+          >&AS_MESSAGE_LOG_FD || CODESIGN=
+      $RM codesign-testfile
+      if test "x$CODESIGN" = x; then
+        AC_MSG_RESULT([no])
+      else
+        AC_MSG_RESULT([yes])
+        # Verify that the codesign has --option runtime
+        AC_MSG_CHECKING([if codesign has --option runtime])
+        $RM codesign-testfile
+        $TOUCH codesign-testfile
+        $CODESIGN --option runtime -s "$MACOSX_CODESIGN_IDENTITY" codesign-testfile \
+            2>&AS_MESSAGE_LOG_FD >&AS_MESSAGE_LOG_FD || CODESIGN=
+        $RM codesign-testfile
+        if test "x$CODESIGN" = x; then
+          AC_MSG_ERROR([codesign does not have --option runtime. macOS 10.13.6 and above is required.])
+        else
+          AC_MSG_RESULT([yes])
+        fi
+      fi
+    fi
     UTIL_REQUIRE_PROGS(SETFILE, SetFile)
   fi
   if ! test "x$OPENJDK_TARGET_OS" = "xwindows"; then

--- make/autoconf/compare.sh.in
+++ make/autoconf/compare.sh.in
@@ -40,7 +40,6 @@
 export BASH="@BASH@"
 export CAT="@CAT@"
 export CMP="@CMP@"
-export CODESIGN="@CODESIGN@"
 export CP="@CP@"
 export CUT="@CUT@"
 export DIFF="@DIFF@"

--- make/autoconf/configure.ac
+++ make/autoconf/configure.ac
@@ -249,7 +249,6 @@
 JDKOPT_ENABLE_DISABLE_MANPAGES
 JDKOPT_ENABLE_DISABLE_CDS_ARCHIVE
 JDKOPT_ENABLE_DISABLE_COMPATIBLE_CDS_ALIGNMENT
-JDKOPT_SETUP_MACOSX_SIGNING
 
 ###############################################################################
 #
--- make/autoconf/jdk-options.m4
+++ make/autoconf/jdk-options.m4
@@ -727,105 +727,3 @@
   AC_SUBST(SOURCE_DATE)
   AC_SUBST(ENABLE_REPRODUCIBLE_BUILD)
 ])
-
-################################################################################
-#
-# Setup signing on macOS. This can either be setup to sign with a real identity
-# and enabling the hardened runtime, or it can simply add the debug entitlement
-# com.apple.security.get-task-allow without actually signing any binaries. The
-# latter is needed to be able to debug processes and dump core files on modern
-# versions of macOS. It can also be skipped completely.
-#
-# Check if codesign will run with the given parameters
-# $1: Parameters to run with
-# $2: Checking message
-# Sets CODESIGN_SUCCESS=true/false
-AC_DEFUN([JDKOPT_CHECK_CODESIGN_PARAMS],
-[
-  PARAMS="$1"
-  MESSAGE="$2"
-  CODESIGN_TESTFILE="$CONFIGURESUPPORT_OUTPUTDIR/codesign-testfile"
-  $RM "$CODESIGN_TESTFILE"
-  $TOUCH "$CODESIGN_TESTFILE"
-  CODESIGN_SUCCESS=false
-  $CODESIGN $PARAMS "$CODESIGN_TESTFILE" 2>&AS_MESSAGE_LOG_FD \
-      >&AS_MESSAGE_LOG_FD && CODESIGN_SUCCESS=true
-  $RM "$CODESIGN_TESTFILE"
-  AC_MSG_CHECKING([$MESSAGE])
-  if test "x$CODESIGN_SUCCESS" = "xtrue"; then
-    AC_MSG_RESULT([yes])
-  else
-    AC_MSG_RESULT([no])
-  fi
-])
-
-AC_DEFUN([JDKOPT_CHECK_CODESIGN_HARDENED],
-[
-  JDKOPT_CHECK_CODESIGN_PARAMS([-s "$MACOSX_CODESIGN_IDENTITY" --option runtime],
-      [if codesign with hardened runtime is possible])
-])
-
-AC_DEFUN([JDKOPT_CHECK_CODESIGN_DEBUG],
-[
-  JDKOPT_CHECK_CODESIGN_PARAMS([-s -], [if debug mode codesign is possible])
-])
-
-AC_DEFUN([JDKOPT_SETUP_MACOSX_SIGNING],
-[
-  ENABLE_CODESIGN=false
-  if test "x$OPENJDK_TARGET_OS" = "xmacosx" && test "x$CODESIGN" != "x"; then
-
-    UTIL_ARG_WITH(NAME: macosx-codesign, TYPE: literal, OPTIONAL: true,
-        VALID_VALUES: [hardened debug auto], DEFAULT: auto,
-        ENABLED_DEFAULT: true,
-        CHECKING_MSG: [for macosx code signing mode],
-        DESC: [set the macosx code signing mode (hardened, debug, auto)]
-    )
-
-    MACOSX_CODESIGN_MODE=disabled
-    if test "x$MACOSX_CODESIGN_ENABLED" = "xtrue"; then
-
-      # Check for user provided code signing identity.
-      UTIL_ARG_WITH(NAME: macosx-codesign-identity, TYPE: string,
-          DEFAULT: openjdk_codesign, CHECK_VALUE: UTIL_CHECK_STRING_NON_EMPTY,
-          DESC: [specify the macosx code signing identity],
-          CHECKING_MSG: [for macosx code signing identity]
-      )
-      AC_SUBST(MACOSX_CODESIGN_IDENTITY)
-
-      if test "x$MACOSX_CODESIGN" = "xauto"; then
-        # Only try to default to hardened signing on release builds
-        if test "x$DEBUG_LEVEL" = "xrelease"; then
-          JDKOPT_CHECK_CODESIGN_HARDENED
-          if test "x$CODESIGN_SUCCESS" = "xtrue"; then
-            MACOSX_CODESIGN_MODE=hardened
-          fi
-        fi
-        if test "x$MACOSX_CODESIGN_MODE" = "xdisabled"; then
-          JDKOPT_CHECK_CODESIGN_DEBUG
-          if test "x$CODESIGN_SUCCESS" = "xtrue"; then
-            MACOSX_CODESIGN_MODE=debug
-          fi
-        fi
-        AC_MSG_CHECKING([for macosx code signing mode])
-        AC_MSG_RESULT([$MACOSX_CODESIGN_MODE])
-      elif test "x$MACOSX_CODESIGN" = "xhardened"; then
-        JDKOPT_CHECK_CODESIGN_HARDENED
-        if test "x$CODESIGN_SUCCESS" = "xfalse"; then
-          AC_MSG_ERROR([Signing with hardened runtime is not possible])
-        fi
-        MACOSX_CODESIGN_MODE=hardened
-      elif test "x$MACOSX_CODESIGN" = "xdebug"; then
-        JDKOPT_CHECK_CODESIGN_DEBUG
-        if test "x$CODESIGN_SUCCESS" = "xfalse"; then
-          AC_MSG_ERROR([Signing in debug mode is not possible])
-        fi
-        MACOSX_CODESIGN_MODE=debug
-      else
-        AC_MSG_ERROR([unknown value for --with-macosx-codesign: $MACOSX_CODESIGN])
-      fi
-    fi
-    AC_SUBST(MACOSX_CODESIGN_IDENTITY)
-    AC_SUBST(MACOSX_CODESIGN_MODE)
-  fi
-])

--- make/autoconf/spec.gmk.in
+++ make/autoconf/spec.gmk.in
@@ -443,8 +443,7 @@
 # The highest allowed version of macosx
 MACOSX_VERSION_MAX=@MACOSX_VERSION_MAX@
 
-# The macosx code signing configuration
-MACOSX_CODESIGN_MODE:=@MACOSX_CODESIGN_MODE@
+# The macosx code signing identity to use
 MACOSX_CODESIGN_IDENTITY=@MACOSX_CODESIGN_IDENTITY@
 
 # Toolchain type: gcc, clang, xlc, microsoft...

--- make/common/NativeCompilation.gmk
+++ make/common/NativeCompilation.gmk
@@ -267,15 +267,10 @@
 # specialized file is found, returns the default file.
 # $1 Executable to find entitlements file for.
 ENTITLEMENTS_DIR := $(TOPDIR)/make/data/macosxsigning
-ifeq ($(MACOSX_CODESIGN_MODE), debug)
-  CODESIGN_PLIST_SUFFIX := -debug
-else
-  CODESIGN_PLIST_SUFFIX :=
-endif
-DEFAULT_ENTITLEMENTS_FILE := $(ENTITLEMENTS_DIR)/default$(CODESIGN_PLIST_SUFFIX).plist
+DEFAULT_ENTITLEMENTS_FILE := $(ENTITLEMENTS_DIR)/default.plist
 
 GetEntitlementsFile = \
-    $(foreach f, $(ENTITLEMENTS_DIR)/$(strip $(notdir $1))$(CODESIGN_PLIST_SUFFIX).plist, \
+    $(foreach f, $(ENTITLEMENTS_DIR)/$(strip $(notdir $1)).plist, \
       $(if $(wildcard $f), $f, $(DEFAULT_ENTITLEMENTS_FILE)) \
     )
 
@@ -1211,16 +1206,11 @@
 		    $$($1_MT) -nologo -manifest $$($1_MANIFEST) -identity:"$$($1_NAME).exe, version=$$($1_MANIFEST_VERSION)" -outputresource:$$@;#1
                   endif
                 endif
-                # On macosx, optionally run codesign on every binary.
-                # Remove signature explicitly first to avoid warnings if the linker
-                # added a default adhoc signature.
-                ifeq ($(MACOSX_CODESIGN_MODE), hardened)
-		  $(CODESIGN) --remove-signature $$@
+                # This only works if the openjdk_codesign identity is present on the system. Let
+                # silently fail otherwise.
+                ifneq ($(CODESIGN), )
 		  $(CODESIGN) -f -s "$(MACOSX_CODESIGN_IDENTITY)" --timestamp --options runtime \
 		      --entitlements $$(call GetEntitlementsFile, $$@) $$@
-                else ifeq ($(MACOSX_CODESIGN_MODE), debug)
-		  $(CODESIGN) --remove-signature $$@
-		  $(CODESIGN) -f -s - --entitlements $$(call GetEntitlementsFile, $$@) $$@
                 endif
   endif
 
--- make/scripts/compare.sh
+++ make/scripts/compare.sh
@@ -42,7 +42,6 @@
     LDD_CMD="$OTOOL -L"
     DIS_CMD="$OTOOL -v -V -t"
     STAT_PRINT_SIZE="-f %z"
-    STRIP="$STRIP -no_code_signature_warning"
 elif [ "$OPENJDK_TARGET_OS" = "windows" ]; then
     FULLDUMP_CMD="$DUMPBIN -all"
     LDD_CMD="$DUMPBIN -dependents"
@@ -675,22 +674,14 @@
     ORIG_THIS_FILE="$THIS_FILE"
     ORIG_OTHER_FILE="$OTHER_FILE"
 
-    if [ "$STRIP_ALL" = "true" ] || [[ "$STRIP_BEFORE_COMPARE" = *"$BIN_FILE"* ]] \
-           || [ "$OPENJDK_TARGET_OS" = "macosx" ]; then
+    if [ "$STRIP_ALL" = "true" ] || [[ "$STRIP_BEFORE_COMPARE" = *"$BIN_FILE"* ]]; then
         THIS_STRIPPED_FILE=$FILE_WORK_DIR/this/$NAME
         OTHER_STRIPPED_FILE=$FILE_WORK_DIR/other/$NAME
         $MKDIR -p $FILE_WORK_DIR/this $FILE_WORK_DIR/other
         $CP $THIS_FILE $THIS_STRIPPED_FILE
         $CP $OTHER_FILE $OTHER_STRIPPED_FILE
-        if [ "$STRIP_ALL" = "true" ] || [[ "$STRIP_BEFORE_COMPARE" = *"$BIN_FILE"* ]]; then
             $STRIP $THIS_STRIPPED_FILE
             $STRIP $OTHER_STRIPPED_FILE
-        fi
-        # On macosx, always remove any signature before comparing
-        if [ "$OPENJDK_TARGET_OS" = "macosx" ]; then
-            $CODESIGN --remove-signature $THIS_STRIPPED_FILE
-            $CODESIGN --remove-signature $OTHER_STRIPPED_FILE
-        fi
         THIS_FILE="$THIS_STRIPPED_FILE"
         OTHER_FILE="$OTHER_STRIPPED_FILE"
     fi

--- src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.h
+++ src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.h
@@ -76,7 +76,6 @@
 void eventHandler_lock(void);
 void eventHandler_unlock(void);
 
-jboolean eventHandler_synthesizeUnloadEvent(char *signature, JNIEnv *env);
 
 jclass getMethodClass(jvmtiEnv *jvmti_env, jmethodID method);
 
--- src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.c
+++ src/jdk.jdwp.agent/share/native/libjdwp/eventHandler.c
@@ -457,10 +457,16 @@
     }
 }
 
-/* Create a synthetic class unload event for the specified signature. */
-jboolean
-eventHandler_synthesizeUnloadEvent(char *signature, JNIEnv *env)
+/* A bagEnumerateFunction.  Create a synthetic class unload event
+ * for every class no longer present.  Analogous to event_callback
+ * combined with a handler in a unload specific (no event
+ * structure) kind of way.
+ */
+static jboolean
+synthesizeUnloadEvent(void *signatureVoid, void *envVoid)
 {
+    JNIEnv *env = (JNIEnv *)envVoid;
+    char *signature = *(char **)signatureVoid;
     char *classname;
     HandlerNode *node;
     jbyte eventSessionID = currentSessionID;
@@ -554,10 +560,39 @@
     currentException = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
     JNI_FUNC_PTR(env,ExceptionClear)(env);
 
-    /* See if a garbage collection finish event happened earlier. */
-    if ( garbageCollected > 0) {
+    /* See if a garbage collection finish event happened earlier.
+     *
+     * Note: The "if" is an optimization to avoid entering the lock on every
+     *       event; garbageCollected may be zapped before we enter
+     *       the lock but then this just becomes one big no-op.
+     */
+    if ( garbageCollected > 0 ) {
+        struct bag *unloadedSignatures = NULL;
+
+        /* We want to compact the hash table of all
+         * objects sent to the front end by removing objects that have
+         * been collected.
+         */
         commonRef_compact();
+
+        /* We also need to simulate the class unload events. */
+
+        debugMonitorEnter(handlerLock);
+
+        /* Clear garbage collection counter */
         garbageCollected = 0;
+
+        /* Analyze which class unloads occurred */
+        unloadedSignatures = classTrack_processUnloads(env);
+
+        debugMonitorExit(handlerLock);
+
+        /* Generate the synthetic class unload events and/or just cleanup.  */
+        if ( unloadedSignatures != NULL ) {
+            (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,
+                             (void *)env);
+            bagDestroyBag(unloadedSignatures);
+        }
     }
 
     thread = evinfo->thread;
@@ -1592,6 +1627,9 @@
 
     node->handlerID = external? ++requestIdCounter : 0;
     error = eventFilterRestricted_install(node);
+    if (node->ei == EI_GC_FINISH) {
+        classTrack_activate(getEnv());
+    }
     if (error == JVMTI_ERROR_NONE) {
         insert(getHandlerChain(node->ei), node);
     }
--- src/jdk.jdwp.agent/share/native/libjdwp/classTrack.c
+++ src/jdk.jdwp.agent/share/native/libjdwp/classTrack.c
@@ -37,7 +37,6 @@
 #include "util.h"
 #include "bag.h"
 #include "classTrack.h"
-#include "eventHandler.h"
 
 #define NOT_TAGGED 0
 
@@ -47,14 +46,64 @@
 static jvmtiEnv* trackingEnv;
 
 /*
- * Invoke the callback when classes are freed.
+ * A bag containing all the deleted classes' signatures. Must be accessed under
+ * classTrackLock.
  */
-void JNICALL
+struct bag* deletedSignatures;
+
+/*
+ * Lock to keep integrity of deletedSignatures.
+ */
+static jrawMonitorID classTrackLock;
+
+/*
+ * Invoke the callback when classes are freed, find and record the signature
+ * in deletedSignatures. Those are only used in addPreparedClass() by the
+ * same thread.
+ */
+static void JNICALL
 cbTrackingObjectFree(jvmtiEnv* jvmti_env, jlong tag)
 {
-    eventHandler_synthesizeUnloadEvent((char*)jlong_to_ptr(tag), getEnv());
+    debugMonitorEnter(classTrackLock);
+    if (deletedSignatures == NULL) {
+      debugMonitorExit(classTrackLock);
+      return;
+    }
+    *(char**)bagAdd(deletedSignatures) = (char*)jlong_to_ptr(tag);
+
+    debugMonitorExit(classTrackLock);
+}
+
+/*
+ * Called after class unloads have occurred.
+ * The signatures of classes which were unloaded are returned.
+ */
+struct bag *
+classTrack_processUnloads(JNIEnv *env)
+{
+    if (deletedSignatures == NULL) {
+      return NULL;
+    }
+
+    /* Allocate new bag outside classTrackLock lock to avoid deadlock.
+     *
+     * Note: jvmtiAllocate/jvmtiDeallocate() may be blocked by ongoing safepoints.
+     * It is dangerous to call them (via bagCreateBag/bagDestroyBag()) while holding monitor(s),
+     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing
+     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),
+     * which can lead to deadlock.
+     */
+    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);
+    debugMonitorEnter(classTrackLock);
+    struct bag* deleted = deletedSignatures;
+    deletedSignatures = new_bag;
+    debugMonitorExit(classTrackLock);
+    return deleted;
 }
 
+/*
+ * Add a class to the prepared class table.
+ */
 void
 classTrack_addPreparedClass(JNIEnv *env_unused, jclass klass)
 {
@@ -113,6 +162,8 @@
 void
 classTrack_initialize(JNIEnv *env)
 {
+    deletedSignatures = NULL;
+    classTrackLock = debugMonitorCreate("Deleted class tag lock");
     trackingEnv = getSpecialJvmti();
     if (trackingEnv == NULL) {
         EXIT_ERROR(AGENT_ERROR_INTERNAL, "Failed to allocate tag-tracking jvmtiEnv");
@@ -144,3 +195,44 @@
         EXIT_ERROR(error,"loaded classes array");
     }
 }
+
+/*
+ * Called to activate class-tracking when a listener registers for EI_GC_FINISH.
+ */
+void
+classTrack_activate(JNIEnv *env)
+{
+    // Allocate bag outside classTrackLock lock to avoid deadlock.
+    // See comments in classTrack_processUnloads() for details.
+    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);
+    debugMonitorEnter(classTrackLock);
+    deletedSignatures = new_bag;
+    debugMonitorExit(classTrackLock);
+}
+
+static jboolean
+cleanDeleted(void *signatureVoid, void *arg)
+{
+    char* sig = *(char**)signatureVoid;
+    jvmtiDeallocate(sig);
+    return JNI_TRUE;
+}
+
+/*
+ * Called when agent detaches.
+ */
+void
+classTrack_reset(void)
+{
+    debugMonitorEnter(classTrackLock);
+    struct bag* to_delete = deletedSignatures;
+    deletedSignatures = NULL;
+    debugMonitorExit(classTrackLock);
+
+    // Deallocate bag outside classTrackLock to avoid deadlock.
+    // See comments in classTrack_processUnloads() for details.
+    if (to_delete != NULL) {
+      bagEnumerateOver(to_delete, cleanDeleted, NULL);
+      bagDestroyBag(to_delete);
+    }
+}

--- src/java.base/share/native/libverify/check_code.c
+++ src/java.base/share/native/libverify/check_code.c
@@ -605,7 +604,7 @@
     unsigned short *pID;
     const char *name = JVM_GetClassNameUTF(env, cb);
 
-    check_and_push_string_utf(context, name);
+    check_and_push(context, name, VM_STRING_UTF);
     hash = class_hash_fun(name);
     pID = &(class_hash->table[hash % HASH_TABLE_SIZE]);
     while (*pID) {
@@ -940,10 +939,10 @@
     int i;
 
     lengths = malloc(sizeof(int) * num_methods);
-    check_and_push_malloc_block(context, lengths);
+    check_and_push(context, lengths, VM_MALLOC_BLK);
 
     code = malloc(sizeof(unsigned char*) * num_methods);
-    check_and_push_malloc_block(context, code);
+    check_and_push(context, code, VM_MALLOC_BLK);
 
     *(lengths_addr) = lengths;
     *(code_addr) = code;
@@ -952,7 +951,7 @@
         lengths[i] = JVM_GetMethodIxByteCodeLength(context->env, cb, i);
         if (lengths[i] > 0) {
             code[i] = malloc(sizeof(unsigned char) * (lengths[i] + 1));
-            check_and_push_malloc_block(context, code[i]);
+            check_and_push(context, code[i], VM_MALLOC_BLK);
             JVM_GetMethodIxByteCode(context->env, cb, i, code[i]);
         } else {
             code[i] = NULL;
@@ -1306,7 +1305,7 @@
         /* Make sure the constant pool item is the right type. */
         verify_constant_pool_type(context, key, kind);
         methodname = JVM_GetCPMethodNameUTF(env, cb, key);
-        check_and_push_string_utf(context, methodname);
+        check_and_push(context, methodname, VM_STRING_UTF);
         is_constructor = !strcmp(methodname, "<init>");
         is_internal = methodname[0] == '<';
         pop_and_free(context);
@@ -1355,7 +1354,7 @@
             unsigned int args2;
             const char *signature =
                 JVM_GetCPMethodSignatureUTF(env, context->class, key);
-            check_and_push_string_utf(context, signature);
+            check_and_push(context, signature, VM_STRING_UTF);
             args1 = signature_to_args_size(signature) + 1;
             args2 = code[offset + 3];
             if (args1 != args2) {
@@ -1653,7 +1652,7 @@
             classname = JVM_GetCPClassNameUTF(env,
                                               context->class,
                                               einfo.catchType);
-            check_and_push_string_utf(context, classname);
+            check_and_push(context, classname, VM_STRING_UTF);
             stack_item->item = make_class_info_from_name(context, classname);
             if (!isAssignableTo(context,
                                 stack_item->item,
@@ -1808,7 +1807,7 @@
         }
     }
     signature = JVM_GetMethodIxSignatureUTF(env, cb, mi);
-    check_and_push_string_utf(context, signature);
+    check_and_push(context, signature, VM_STRING_UTF);
     /* Fill in each of the arguments into the registers. */
     for (p = signature + 1; *p != JVM_SIGNATURE_ENDFUNC; ) {
         char fieldchar = signature_to_fieldtype(context, &p, &full_info);
@@ -2051,7 +2050,7 @@
                                            context->class,
                                            operand);
             char *ip = buffer;
-            check_and_push_string_utf(context, signature);
+            check_and_push(context, signature, VM_STRING_UTF);
 #ifdef DEBUG
             if (verify_verbose) {
                 print_formatted_fieldname(context, operand);
@@ -2077,7 +2076,7 @@
                                             operand);
             char *ip = buffer;
             const char *p;
-            check_and_push_string_utf(context, signature);
+            check_and_push(context, signature, VM_STRING_UTF);
 #ifdef DEBUG
             if (verify_verbose) {
                 print_formatted_methodname(context, operand);
@@ -2377,7 +2376,7 @@
                                             operand);
             int item;
             const char *p;
-            check_and_push_string_utf(context, signature);
+            check_and_push(context, signature, VM_STRING_UTF);
             if (opcode == JVM_OPC_invokestatic) {
                 item = 0;
             } else if (opcode == JVM_OPC_invokeinit) {
@@ -2759,7 +2758,7 @@
             const char *signature = JVM_GetCPFieldSignatureUTF(context->env,
                                                                context->class,
                                                                operand);
-            check_and_push_string_utf(context, signature);
+            check_and_push(context, signature, VM_STRING_UTF);
 #ifdef DEBUG
             if (verify_verbose) {
                 print_formatted_fieldname(context, operand);
@@ -2781,7 +2780,7 @@
                                                                 context->class,
                                                                 operand);
             const char *result_signature;
-            check_and_push_string_utf(context, signature);
+            check_and_push(context, signature, VM_STRING_UTF);
             result_signature = get_result_signature(signature);
             if (result_signature++ == NULL) {
                 CCerror(context, "Illegal signature %s", signature);
@@ -3622,7 +3621,7 @@
         CCerror(context, "Internal error #5");
     }
 
-    check_and_push_string_utf(context, classname);
+    check_and_push(context, classname, VM_STRING_UTF);
     if (classname[0] == JVM_SIGNATURE_ARRAY) {
         /* This make recursively call us, in case of a class array */
         signature_to_fieldtype(context, &classname, &result);
@@ -3823,8 +3822,8 @@
                 assert(finish >= p);
                 length = (int)(finish - p);
                 if (length + 1 > (int)sizeof(buffer_space)) {
-                    buffer = malloc(length + 1);
-                    check_and_push_malloc_block(context, buffer);
+                    buffer = calloc(length + 1, sizeof(char));
+                    check_and_push(context, buffer, VM_MALLOC_BLK);
                 }
                 memcpy(buffer, p, length);
                 buffer[length] = '\0';
@@ -4143,7 +4142,7 @@
     }
 }
 
-static void check_and_push_common(context_type *context, void *ptr, int kind)
+static void check_and_push(context_type *context, const void *ptr, int kind)
 {
     alloc_stack_type *p;
     if (ptr == 0)
@@ -4155,24 +4154,16 @@
         p = malloc(sizeof(alloc_stack_type));
         if (p == 0) {
             /* Make sure we clean up. */
-            free_block(ptr, kind);
+            free_block((void *)ptr, kind);
             CCout_of_memory(context);
         }
     }
     p->kind = kind;
-    p->ptr = ptr;
+    p->ptr = (void *)ptr;
     p->next = context->allocated_memory;
     context->allocated_memory = p;
 }
 
-static void check_and_push_malloc_block(context_type *context, void *ptr) {
-  check_and_push_common(context, ptr, VM_MALLOC_BLK);
-}
-
-static void check_and_push_string_utf(context_type *context, const char *ptr) {
-  check_and_push_common(context, (void *)ptr, VM_STRING_UTF);
-}
-
 static void pop_and_free(context_type *context)
 {
     alloc_stack_type *p = context->allocated_memory;
 
 
